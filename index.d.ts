/* auto-generated by NAPI-RS */
/* eslint-disable */
export declare class DicomFile {
  /** * Create a new DicomFile instance.
   *
   * The instance is initially empty. Call `open()` to load a DICOM file.
   *
   * @param storageConfig - Optional storage configuration for S3 or filesystem with root directory
   *
   * @example
   * ```typescript
   * // Default filesystem storage (current directory)
   * const file1 = new DicomFile();
   *
   * // Filesystem with root directory
   * const file2 = new DicomFile({
   *   backend: 'Filesystem',
   *   rootDir: '/data/dicom'
   * });
   *
   * // S3 storage
   * const file3 = new DicomFile({
   *   backend: 'S3',
   *   s3Config: {
   *     bucket: 'my-dicom-bucket',
   *     accessKey: 'ACCESS_KEY',
   *     secretKey: 'SECRET_KEY',
   *     endpoint: 'http://localhost:9000'
   *   }
   * });
   * ```
   */
  constructor(storageConfig?: StorageConfig | undefined | null)
  /** * Check if a file is a valid DICOM file and extract its metadata.
   *
   * This is a lightweight operation that only reads the file meta information
   * without loading the entire dataset. Useful for quickly validating files
   * or extracting SOPInstanceUID without a full file open.
   *
   * @param path - Absolute or relative path to the DICOM file
   * @returns DicomFileMeta containing SOP Class UID and SOP Instance UID
   * @throws Error if the file is not a valid DICOM file or DICOMDIR
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * const meta = file.check('/path/to/file.dcm');
   * console.log(meta.sopInstanceUid);
   * ```
   */
  check(path: string): DicomFileMeta
  /** * Open and load a DICOM file into memory.
   *
   * Reads the entire DICOM dataset and makes it available for operations like
   * `extract()`, `saveRawPixelData()`, and `dump()`. Any previously opened file
   * is automatically closed. Automatically uses S3 or filesystem based on configuration.
   *
   * @param path - Path to the DICOM file (filesystem path or S3 key)
   * @returns Success message if the file was opened successfully
   * @throws Error if the file cannot be opened or is not a valid DICOM file
   *
   * @example
   * ```typescript
   * // Filesystem
   * const file1 = new DicomFile();
   * file1.open('/path/to/file.dcm');
   *
   * // S3
   * const file2 = new DicomFile({ backend: 'S3', s3Config: {...} });
   * file2.open('folder/file.dcm'); // Reads from S3 bucket
   * ```
   */
  open(path: string): string
  /** * Open and load a DICOM JSON file into memory.
   *
   * Reads a DICOM file in JSON format (as specified by DICOM Part 18) and converts it
   * to an internal DICOM object representation. After opening, all standard operations
   * like `extract()`, `dump()`, and `saveAsDicom()` are available. Automatically uses S3 or filesystem.
   *
   * @param path - Path to the DICOM JSON file (filesystem path or S3 key)
   * @returns Success message if the file was opened successfully
   * @throws Error if the file cannot be opened or is not valid DICOM JSON
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * file.openJson('/path/to/file.json');
   * const data = file.extract(['PatientName', 'StudyDate'], undefined, 'Flat');
   * ```
   */
  openJson(path: string): string
  /** * Print a detailed dump of the DICOM file structure to stdout.
   *
   * Displays all DICOM elements with their tags, VRs, and values in a human-readable format.
   * Useful for debugging and inspecting DICOM file contents.
   *
   * @throws Error if no file is currently opened
   */
  dump(): void
  /** * Extract and save raw pixel data to a file.
   *
   * Extracts the raw pixel data bytes from the DICOM file's PixelData element (7FE0,0010)
   * and writes them directly to a binary file. The data is saved as-is without any
   * decompression or conversion. Useful for extracting raw image data for custom processing.
   *
   * Note: This does not decode or decompress the pixel data. For compressed transfer syntaxes
   * (e.g., JPEG, JPEG 2000), the output will be the compressed bitstream.
   *
   * @param path - Output path where the raw pixel data will be saved
   * @returns Success message with the number of bytes written
   * @throws Error if no file is opened, pixel data is missing, or file write fails
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * file.open('image.dcm');
   * file.saveRawPixelData('output.raw');
   * ```
   */
  saveRawPixelData(path: string): string
  /** * Extract DICOM tags with flexible grouping strategies.
   *
   * Extracts specified DICOM tags and returns them as a JSON string, organized according
   * to the chosen grouping strategy. Supports any tag name from the DICOM standard or
   * hex format (e.g., "00100010").
   *
   * ## Grouping Strategies
   *
   * - **"ByScope"** (default): Groups tags by DICOM hierarchy levels (Patient, Study, Series, Instance, Equipment)
   * - **"Flat"**: Returns all tags in a flat key-value structure
   * - **"StudyLevel"**: Groups into studyLevel (Patient+Study) and instanceLevel (Series+Instance+Equipment)
   * - **"Custom"**: Reserved for user-defined grouping rules (currently behaves like ByScope)
   *
   * ## Tag Name Formats
   *
   * Tags can be specified in multiple formats:
   * - Standard name: "PatientName", "StudyDate", "Modality"
   * - Hex format: "00100010", "00080020", "00080060"
   * - Any valid DICOM tag from StandardDataDictionary
   *
   * ## Custom Tags
   *
   * Custom tags allow extraction of private or vendor-specific tags with user-defined names:
   * ```typescript
   * import { createCustomTag } from '@nuxthealth/node-dicom';
   *
   * file.extract(
   *   ['PatientName'],
   *   [createCustomTag('00091001', 'VendorPrivateTag')],
   *   'ByScope'
   * );
   * ```
   *
   * @param tagNames - Array of DICOM tag names or hex values to extract. Supports 300+ autocomplete suggestions.
   * @param customTags - Optional array of custom tag specifications for private/vendor tags
   * @param strategy - Grouping strategy: "ByScope" | "Flat" | "StudyLevel" | "Custom" (default: "ByScope")
   * @returns JSON string containing extracted tags, structure depends on grouping strategy
   * @throws Error if no file is opened or JSON serialization fails
   *
   * @example
   * ```typescript
   * // Scoped grouping (default)
   * const json = file.extract(['PatientName', 'StudyDate', 'Modality'], undefined, 'ByScope');
   * const data = JSON.parse(json);
   * // { patient: { PatientName: "..." }, study: { StudyDate: "..." }, series: { Modality: "..." } }
   *
   * // Flat structure
   * const flatJson = file.extract(['PatientName', 'StudyDate'], undefined, 'Flat');
   * // { "PatientName": "...", "StudyDate": "..." }
   *
   * // Use predefined tag sets
   * import { getCommonTagSets, combineTags } from '@nuxthealth/node-dicom';
   * const tags = getCommonTagSets();
   * const allTags = combineTags([tags.patientBasic, tags.studyBasic, tags.ct]);
   * const extracted = file.extract(allTags, undefined, 'StudyLevel');
   * ```
   */
  extract(tagNames: Array<'AccessionNumber' | 'AcquisitionDate' | 'AcquisitionDateTime' | 'AcquisitionNumber' | 'AcquisitionTime' | 'ActualCardiacTriggerTimePriorToRPeak' | 'ActualFrameDuration' | 'AdditionalPatientHistory' | 'AdmissionID' | 'AdmittingDiagnosesDescription' | 'AnatomicalOrientationType' | 'AnatomicRegionSequence' | 'AnodeTargetMaterial' | 'BeamLimitingDeviceAngle' | 'BitsAllocated' | 'BitsStored' | 'BluePaletteColorLookupTableDescriptor' | 'BodyPartExamined' | 'BodyPartThickness' | 'BranchOfService' | 'BurnedInAnnotation' | 'ChannelSensitivity' | 'CineRate' | 'CollimatorType' | 'Columns' | 'CompressionForce' | 'ContentDate' | 'ContentTime' | 'ContrastBolusAgent' | 'ContrastBolusIngredient' | 'ContrastBolusIngredientConcentration' | 'ContrastBolusRoute' | 'ContrastBolusStartTime' | 'ContrastBolusStopTime' | 'ContrastBolusTotalDose' | 'ContrastBolusVolume' | 'ContrastFlowDuration' | 'ContrastFlowRate' | 'ConvolutionKernel' | 'CorrectedImage' | 'CountsSource' | 'DataCollectionDiameter' | 'DecayCorrection' | 'DeidentificationMethod' | 'DerivationDescription' | 'DetectorTemperature' | 'DeviceSerialNumber' | 'DistanceSourceToDetector' | 'DistanceSourceToPatient' | 'EchoTime' | 'EthnicGroup' | 'Exposure' | 'ExposureInMicroAmpereSeconds' | 'ExposureTime' | 'FilterType' | 'FlipAngle' | 'FocalSpots' | 'FrameDelay' | 'FrameIncrementPointer' | 'FrameOfReferenceUID' | 'FrameTime' | 'GantryAngle' | 'GeneratorPower' | 'GraphicAnnotationSequence' | 'GreenPaletteColorLookupTableDescriptor' | 'HeartRate' | 'HighBit' | 'ImageComments' | 'ImageLaterality' | 'ImageOrientationPatient' | 'ImagePositionPatient' | 'ImagerPixelSpacing' | 'ImageTriggerDelay' | 'ImageType' | 'ImagingFrequency' | 'ImplementationClassUID' | 'ImplementationVersionName' | 'InstanceCreationDate' | 'InstanceCreationTime' | 'InstanceNumber' | 'InstitutionName' | 'IntensifierSize' | 'IssuerOfAdmissionID' | 'KVP' | 'LargestImagePixelValue' | 'LargestPixelValueInSeries' | 'Laterality' | 'LossyImageCompression' | 'LossyImageCompressionMethod' | 'LossyImageCompressionRatio' | 'MagneticFieldStrength' | 'Manufacturer' | 'ManufacturerModelName' | 'MedicalRecordLocator' | 'MilitaryRank' | 'Modality' | 'MultiplexGroupTimeOffset' | 'NameOfPhysiciansReadingStudy' | 'NominalCardiacTriggerDelayTime' | 'NominalInterval' | 'NumberOfFrames' | 'NumberOfSlices' | 'NumberOfTemporalPositions' | 'NumberOfWaveformChannels' | 'NumberOfWaveformSamples' | 'Occupation' | 'OperatorsName' | 'OtherPatientIDs' | 'OtherPatientNames' | 'OverlayBitPosition' | 'OverlayBitsAllocated' | 'OverlayColumns' | 'OverlayData' | 'OverlayOrigin' | 'OverlayRows' | 'OverlayType' | 'PaddleDescription' | 'PatientAge' | 'PatientBirthDate' | 'PatientBreedDescription' | 'PatientComments' | 'PatientID' | 'PatientIdentityRemoved' | 'PatientName' | 'PatientPosition' | 'PatientSex' | 'PatientSize' | 'PatientSpeciesDescription' | 'PatientSupportAngle' | 'PatientTelephoneNumbers' | 'PatientWeight' | 'PerformedProcedureStepDescription' | 'PerformedProcedureStepID' | 'PerformedProcedureStepStartDate' | 'PerformedProcedureStepStartTime' | 'PerformedProtocolCodeSequence' | 'PerformingPhysicianName' | 'PhotometricInterpretation' | 'PhysiciansOfRecord' | 'PixelAspectRatio' | 'PixelPaddingRangeLimit' | 'PixelPaddingValue' | 'PixelRepresentation' | 'PixelSpacing' | 'PlanarConfiguration' | 'PositionerPrimaryAngle' | 'PositionerSecondaryAngle' | 'PositionReferenceIndicator' | 'PreferredPlaybackSequencing' | 'PresentationIntentType' | 'PresentationLUTShape' | 'PrimaryAnatomicStructureSequence' | 'PrivateInformationCreatorUID' | 'ProtocolName' | 'QualityControlImage' | 'RadiationMachineName' | 'RadiationSetting' | 'RadionuclideTotalDose' | 'RadiopharmaceuticalInformationSequence' | 'RadiopharmaceuticalStartDateTime' | 'RadiopharmaceuticalStartTime' | 'RadiopharmaceuticalVolume' | 'ReasonForTheRequestedProcedure' | 'ReceivingApplicationEntityTitle' | 'RecognizableVisualFeatures' | 'RecommendedDisplayFrameRate' | 'ReconstructionDiameter' | 'ReconstructionTargetCenterPatient' | 'RedPaletteColorLookupTableDescriptor' | 'ReferencedBeamNumber' | 'ReferencedImageSequence' | 'ReferencedPatientPhotoSequence' | 'ReferencedPerformedProcedureStepSequence' | 'ReferencedRTPlanSequence' | 'ReferencedSOPClassUID' | 'ReferencedSOPInstanceUID' | 'ReferencedStudySequence' | 'ReferringPhysicianName' | 'RepetitionTime' | 'RequestAttributesSequence' | 'RequestedContrastAgent' | 'RequestedProcedureDescription' | 'RequestedProcedureID' | 'RequestingPhysician' | 'RescaleIntercept' | 'RescaleSlope' | 'RescaleType' | 'ResponsibleOrganization' | 'ResponsiblePerson' | 'ResponsiblePersonRole' | 'Rows' | 'RTImageDescription' | 'RTImageLabel' | 'SamplesPerPixel' | 'SamplingFrequency' | 'ScanningSequence' | 'SendingApplicationEntityTitle' | 'SeriesDate' | 'SeriesDescription' | 'SeriesInstanceUID' | 'SeriesNumber' | 'SeriesTime' | 'SeriesType' | 'SliceLocation' | 'SliceThickness' | 'SmallestImagePixelValue' | 'SmallestPixelValueInSeries' | 'SoftwareVersions' | 'SOPClassUID' | 'SOPInstanceUID' | 'SoundPathLength' | 'SourceApplicationEntityTitle' | 'SourceImageSequence' | 'SpacingBetweenSlices' | 'SpecificCharacterSet' | 'StationName' | 'StudyComments' | 'StudyDate' | 'StudyDescription' | 'StudyID' | 'StudyInstanceUID' | 'StudyTime' | 'TableHeight' | 'TableTopLateralPosition' | 'TableTopLongitudinalPosition' | 'TableTopVerticalPosition' | 'TableType' | 'TemporalPositionIdentifier' | 'TemporalResolution' | 'TextObjectSequence' | 'TimezoneOffsetFromUTC' | 'TransducerFrequency' | 'TransducerType' | 'TransferSyntaxUID' | 'TriggerTime' | 'TriggerTimeOffset' | 'UltrasoundColorDataPresent' | 'Units' | 'VOILUTFunction' | 'WaveformOriginality' | 'WaveformSequence' | 'WindowCenter' | 'WindowCenterWidthExplanation' | 'WindowWidth' | 'XRayTubeCurrent' | (string & {})>, customTags?: Array<CustomTag>, strategy?: 'ByScope' | 'Flat' | 'StudyLevel' | 'Custom'): string
  /** * Get comprehensive information about pixel data in the DICOM file.
   *
   * Extracts metadata about the image dimensions, bit depth, photometric interpretation,
   * compression status, and windowing parameters without decoding the actual pixel data.
   *
   * @returns PixelDataInfo object with detailed pixel data metadata
   * @throws Error if no file is opened or pixel data is missing
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * file.open('ct_scan.dcm');
   * const info = file.getPixelDataInfo();
   * console.log(`${info.width}x${info.height}, ${info.frames} frames`);
   * console.log(`Bits: ${info.bitsStored}, Compressed: ${info.isCompressed}`);
   * ```
   */
  getPixelDataInfo(): PixelDataInfo
  /** * Process and extract pixel data with flexible options.
   *
   * Advanced pixel data processing supporting:
   * - Raw extraction or decoded/decompressed output
   * - Multiple output formats (Raw, PNG, JPEG, JSON)
   * - Frame extraction (single or all frames)
   * - Windowing and 8-bit conversion
   * - VOI LUT application
   *
   * @param options - Processing options
   * @returns Success message with processing details
   * @throws Error if processing fails or required features are not available
   *
   * @example
   * ```typescript
   * // Extract raw pixel data
   * file.processPixelData({
   *   outputPath: 'output.raw',
   *   format: 'Raw'
   * });
   *
   * // Decode and save as PNG with windowing
   * file.processPixelData({
   *   outputPath: 'output.png',
   *   format: 'Png',
   *   decode: true,
   *   applyVoiLut: true,
   *   convertTo8bit: true
   * });
   *
   * // Extract specific frame
   * file.processPixelData({
   *   outputPath: 'frame_5.raw',
   *   format: 'Raw',
   *   frameNumber: 5
   * });
   *
   * // Get metadata as JSON
   * file.processPixelData({
   *   outputPath: 'info.json',
   *   format: 'Json'
   * });
   * ```
   */
  processPixelData(options: PixelDataOptions): string
  /** * Save the currently opened DICOM file as JSON format.
   *
   * Converts the DICOM object to JSON representation according to DICOM Part 18
   * standard and saves it to the specified path. Automatically uses S3 or filesystem.
   *
   * @param path - Output path for the JSON file (filesystem path or S3 key)
   * @param pretty - Pretty print the JSON (default: true)
   * @returns Success message with file size
   * @throws Error if no file is opened or JSON conversion fails
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * file.open('image.dcm');
   * file.saveAsJson('output.json', true);
   * ```
   */
  saveAsJson(path: string, pretty?: boolean | undefined | null): string
  /** * Save the currently opened DICOM file (regardless of original format) as standard DICOM.
   *
   * Writes the DICOM object as a standard .dcm file with proper file meta information.
   * Useful for converting DICOM JSON back to binary DICOM format. Automatically uses S3 or filesystem.
   *
   * @param path - Output path for the DICOM file (filesystem path or S3 key)
   * @returns Success message
   * @throws Error if no file is opened or write fails
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * file.openJson('input.json');
   * file.saveAsDicom('output.dcm');
   * ```
   */
  saveAsDicom(path: string): string
  /** * Close the currently opened DICOM file and free memory.
   *
   * Releases the DICOM dataset from memory. After closing, you must call `open()`
   * again before performing any operations that require file data. It's good practice
   * to close files when done to free resources, though the file will be automatically
   * closed when the instance is dropped.
   *
   * @example
   * ```typescript
   * const file = new DicomFile();
   * file.open('file1.dcm');
   * // ... work with file1
   * file.close();
   *
   * file.open('file2.dcm');  // Can reuse same instance
   * // ... work with file2
   * file.close();
   * ```
   */
  close(): void
}

/** DICOM C-STORE SCP */
export declare class StoreScp {
  /** * Create a new DICOM C-STORE SCP server instance.
   *
   * Initializes the server with the provided configuration. The server is not
   * started until `listen()` is called.
   *
   * @param options - Server configuration options
   * @returns New StoreScp instance
   *
   * @example
   * ```typescript
   * // Filesystem storage
   * const scp = new StoreScp({
   *   port: 11111,
   *   outDir: './dicom-data',
   *   verbose: true
   * });
   *
   * // S3 storage with tag extraction
   * const scpS3 = new StoreScp({
   *   port: 11112,
   *   storageBackend: 'S3',
   *   s3Config: {
   *     bucket: 'my-dicom-bucket',
   *     accessKey: process.env.AWS_ACCESS_KEY!,
   *     secretKey: process.env.AWS_SECRET_KEY!,
   *     region: 'us-east-1'
   *   },
   *   extractTags: ['PatientID', 'StudyInstanceUID', 'SeriesInstanceUID'],
   *   studyTimeout: 120
   * });
   * ```
   */
  constructor(options: StoreScpOptions)
  /** * Start the DICOM C-STORE SCP server and begin listening for connections.
   *
   * This method starts the server asynchronously. The server will listen on the
   * configured port and handle incoming DICOM associations. Events will be emitted
   * as files are received and stored.
   *
   * For S3 storage, this method will verify S3 connectivity before starting.
   *
   * @returns Promise that resolves when the server stops
   * @throws Error if S3 connectivity check fails (when using S3 backend)
   *
   * @example
   * ```typescript
   * const scp = new StoreScp({
   *   port: 11111,
   *   outDir: './dicom-storage'
   * });
   *
   * // Add event listeners before starting
   * scp.addEventListener('OnServerStarted', (data) => {
   *   console.log('✓ Server is ready');
   * });
   *
   * scp.addEventListener('OnFileStored', (data) => {
   *   console.log('File received');
   * });
   *
   * // Start server (non-blocking)
   * await scp.listen();
   *
   * // Server is now running in the background
   * console.log('Server started on port 11111');
   * ```
   */
  listen(): Promise<void>
  /** * Stop the DICOM C-STORE SCP server and close all connections.
   *
   * Initiates a graceful shutdown of the server. All active connections will be
   * terminated and the server will stop accepting new connections.
   *
   * @returns Promise that resolves when shutdown is initiated
   *
   * @example
   * ```typescript
   * const scp = new StoreScp({ port: 11111 });
   * await scp.listen();
   *
   * // Later, when you want to stop the server
   * await scp.close();
   * console.log('Server stopped');
   *
   * // Handle graceful shutdown on process signals
   * process.on('SIGINT', async () => {
   *   console.log('Shutting down...');
   *   await scp.close();
   *   process.exit(0);
   * });
   * ```
   */
  close(): Promise<void>
  /** * Register callback for server started events
   */
  onServerStarted(handler: ((err: Error | null, arg: ScpEventData) => void)): void
  /** * Register callback for new connection events
   */
  onConnection(handler: ((err: Error | null, arg: ScpEventData) => void)): void
  /** * Register callback for file stored events
   *
   * Called when a DICOM file has been successfully received and stored.
   * The event data includes file path, SOP UIDs, and extracted DICOM tags.
   */
  onFileStored(handler: ((err: Error | null, arg: ScpEventData) => void)): void
  /** * Register callback for study completed events
   *
   * Called when all files for a study have been received (after study timeout).
   * Includes the complete study hierarchy with all series and instances.
   */
  onStudyCompleted(handler: ((err: Error | null, arg: ScpEventData) => void)): void
  /** * Register callback for error events
   */
  onError(handler: ((err: Error | null, arg: ScpEventData) => void)): void
}

/** * DICOM C-STORE SCU (Service Class User) Client.
 *
 * A complete DICOM client for sending DICOM files to a remote SCP server.
 * Supports both local filesystem and S3 storage, with features including:
 * - Automatic transfer syntax negotiation
 * - Optional transcoding support
 * - Concurrent file transfers
 * - Progress tracking via events
 * - User authentication (username/password, JWT, SAML, Kerberos)
 * - Folder recursion
 *
 * ## Workflow
 * 1. Create a StoreScu instance with connection options
 * 2. Add files or folders using `addFile()` and `addFolder()`
 * 3. Optionally attach event listeners for progress monitoring
 * 4. Call `send()` to initiate the transfer
 *
 * @example
 * ```typescript
 * import { StoreScu } from '@nuxthealth/node-dicom';
 *
 * // Create SCU client
 * const scu = new StoreScu({
 *   addr: 'PACS@192.168.1.100:11112',
 *   callingAeTitle: 'MY-WORKSTATION',
 *   verbose: true
 * });
 *
 * // Add files
 * scu.addFile('/path/to/image1.dcm');
 * scu.addFile('/path/to/image2.dcm');
 * scu.addFolder('/path/to/study/'); // Recursively adds all DICOM files
 *
 * // Monitor progress
 * scu.addEventListener('OnFileSending', (data) => {
 *   const info = JSON.parse(data.data!);
 *   console.log(`Sending: ${info.file}`);
 * });
 *
 * scu.addEventListener('OnFileSent', (data) => {
 *   console.log('File sent successfully');
 * });
 *
 * // Send all files
 * const results = await scu.send();
 * console.log('Transfer complete:', results);
 * ```
 *
 * @example
 * ```typescript
 * // S3 to PACS transfer with concurrent connections
 * const scu = new StoreScu({
 *   addr: 'PACS@pacs.hospital.com:104',
 *   s3Config: {
 *     bucket: 'dicom-archive',
 *     accessKey: process.env.AWS_ACCESS_KEY!,
 *     secretKey: process.env.AWS_SECRET_KEY!,
 *     region: 'us-east-1'
 *   },
 *   concurrency: 4,
 *   username: 'dicom-user',
 *   password: 'secret'
 * });
 *
 * scu.addFolder('patient123/'); // S3 prefix
 * await scu.send();
 * ```
 */
export declare class StoreScu {
  /** * Create a new DICOM C-STORE SCU client instance.
   *
   * Initializes the client with connection parameters. Files must be added
   * using `addFile()` or `addFolder()` before calling `send()`.
   *
   * @param options - Client configuration options
   * @returns New StoreScu instance
   *
   * @example
   * ```typescript
   * // Basic configuration
   * const scu = new StoreScu({
   *   addr: '192.168.1.100:11112',
   *   verbose: true
   * });
   *
   * // With AE titles and authentication
   * const scu2 = new StoreScu({
   *   addr: 'PACS@192.168.1.100:11112',
   *   callingAeTitle: 'WORKSTATION-01',
   *   username: 'dicom-user',
   *   password: 'password123'
   * });
   *
   * // S3 source with high performance
   * const scu3 = new StoreScu({
   *   addr: 'PACS@pacs.hospital.com:104',
   *   s3Config: {
   *     bucket: 'dicom-storage',
   *     accessKey: process.env.AWS_ACCESS_KEY!,
   *     secretKey: process.env.AWS_SECRET_KEY!,
   *     endpoint: 'http://localhost:9000'
   *   },
   *   maxPduLength: 131072,
   *   concurrency: 8
   * });
   * ```
   */
  constructor(options: StoreScuOptions)
  /** * Add a single DICOM file to the transfer queue.
   *
   * The path can be either:
   * - A local filesystem path (when no S3 config provided)
   * - An S3 object key (when S3 config is provided)
   *
   * Files are validated before transfer to ensure they are valid DICOM files
   * and have supported transfer syntaxes.
   *
   * @param path - Path to the DICOM file (local or S3 key)
   *
   * @example
   * ```typescript
   * // Local files
   * const scu = new StoreScu({ addr: '192.168.1.100:11112' });
   * scu.addFile('/data/dicom/image1.dcm');
   * scu.addFile('/data/dicom/image2.dcm');
   * scu.addFile('./relative/path/image3.dcm');
   *
   * // S3 objects
   * const scuS3 = new StoreScu({
   *   addr: '192.168.1.100:11112',
   *   s3Config: { bucket: 'dicom-bucket', ... }
   * });
   * scuS3.addFile('patient123/study456/series789/image.dcm');
   * scuS3.addFile('archive/2024/01/scan.dcm');
   * ```
   */
  addFile(path: string): void
  /** * Add all DICOM files from a folder to the transfer queue.
   *
   * Recursively scans the folder and adds all DICOM files found.
   * Non-DICOM files and DICOMDIR files are automatically skipped.
   *
   * For S3, the path is treated as a prefix, and all objects with that
   * prefix are listed and added (excluding folder markers).
   *
   * @param path - Path to the folder (local or S3 prefix)
   *
   * @example
   * ```typescript
   * // Local folder - recursively adds all DICOM files
   * const scu = new StoreScu({ addr: '192.168.1.100:11112' });
   * scu.addFolder('/data/dicom/study001/');
   * scu.addFolder('./images/'); // Relative paths work too
   *
   * // S3 prefix - adds all objects with this prefix
   * const scuS3 = new StoreScu({
   *   addr: '192.168.1.100:11112',
   *   s3Config: { bucket: 'dicom-bucket', ... }
   * });
   * scuS3.addFolder('patient123/'); // Adds all files under this prefix
   * scuS3.addFolder('archive/2024/01/'); // Year/month organization
   *
   * // Add entire bucket contents (use with caution!)
   * scuS3.addFolder(''); // Empty prefix = entire bucket
   * ```
   */
  addFolder(path: string): void
  /** * Clear all files from the transfer queue.
   *
   * Removes all files that were previously added with `addFile()` or `addFolder()`.
   * Useful for retry logic where you want to re-add only failed files, or when
   * reusing the same StoreScu instance for multiple different transfers.
   *
   * @example
   * ```typescript
   * const scu = new StoreScu({ addr: '192.168.1.100:11112' });
   *
   * // First batch
   * scu.addFile('file1.dcm');
   * scu.addFile('file2.dcm');
   * await scu.send();
   *
   * // Clean and send different files
   * scu.clean();
   * scu.addFile('file3.dcm');
   * await scu.send();
   * ```
   *
   * @example
   * ```typescript
   * // Retry pattern with clean()
   * const scu = new StoreScu({ addr: '192.168.1.100:11112', concurrency: 4 });
   * const failedFiles: string[] = [];
   *
   * // Initial attempt
   * files.forEach(f => scu.addFile(f));
   * await scu.send({
   *   onFileError: (err, event) => {
   *     if (event.data?.file) failedFiles.push(event.data.file);
   *   }
   * });
   *
   * // Retry failed files
   * if (failedFiles.length > 0) {
   *   scu.clean();
   *   failedFiles.forEach(f => scu.addFile(f));
   *   await scu.send();
   * }
   * ```
   */
  clean(): void
  /** * Send all queued DICOM files to the remote SCP.
   *
   * Establishes a DICOM association, negotiates transfer syntaxes, and sends
   * all files that were added via `addFile()` or `addFolder()`. The transfer
   * can be monitored using event listeners.
   *
   * For S3 sources, files are downloaded on-demand during transfer to minimize
   * memory usage. Multiple concurrent connections can be used for improved
   * performance (see `concurrency` option).
   *
   * The method will:
   * 1. Validate all queued files
   * 2. Establish association with the SCP
   * 3. Negotiate presentation contexts
   * 4. Transfer each file
   * 5. Optionally transcode if needed (unless `neverTranscode` is true)
   * 6. Release the association
   *
   * @returns Promise that resolves to an array of result objects
   * @throws Error if connection fails, no files queued, or transfer fails
   *
   * @example
   * ```typescript
   * const scu = new StoreScu({ addr: '192.168.1.100:11112' });
   * scu.addFile('image1.dcm');
   * scu.addFile('image2.dcm');
   *
   * // Simple send
   * const results = await scu.send();
   * console.log('Transfer results:', results);
   * ```
   *
   * @example
   * ```typescript
   * // With progress monitoring
   * const scu = new StoreScu({
   *   addr: 'PACS@192.168.1.100:11112',
   *   verbose: true
   * });
   *
   * scu.addFolder('./dicom-study/');
   *
   * let fileCount = 0;
   * scu.addEventListener('OnFileSent', () => {
   *   fileCount++;
   *   console.log(`Progress: ${fileCount} files sent`);
   * });
   *
   * scu.addEventListener('OnFileError', (data) => {
   *   console.error('File failed:', data.message);
   * });
   *
   * try {
   *   const results = await scu.send();
   *   console.log(`✓ Successfully sent ${fileCount} files`);
   * } catch (error) {
   *   console.error('Transfer failed:', error);
   * }
   * ```
   *
   * @example
   * ```typescript
   * // High-performance S3 to PACS transfer with callbacks
   * const scu = new StoreScu({
   *   addr: 'PACS@pacs.hospital.com:104',
   *   s3Config: {
   *     bucket: 'dicom-archive',
   *     accessKey: process.env.AWS_ACCESS_KEY!,
   *     secretKey: process.env.AWS_SECRET_KEY!
   *   },
   *   concurrency: 8, // 8 parallel connections
   *   maxPduLength: 131072 // 128KB PDU
   * });
   *
   * scu.addFolder('large-study/');
   *
   * await scu.send({
   *   onFileSent: (err, event) => {
   *     console.log('File sent:', event.data.sopInstanceUid);
   *   },
   *   onTransferCompleted: (err, event) => {
   *     console.log('Transfer complete!');
   *   }
   * });
   * ```
   */
  send(callbacks?: { onTransferStarted?: (err: Error | null, event: TransferStartedEvent) => void, onFileSending?: (err: Error | null, event: FileSendingEvent) => void, onFileSent?: (err: Error | null, event: FileSentEvent) => void, onFileError?: (err: Error | null, event: FileErrorEvent) => void, onTransferCompleted?: (err: Error | null, event: TransferCompletedEvent) => void }): Promise<Array<ResultObject>>
}

/** Abstract syntax (SOP Class) acceptance mode */
export declare const enum AbstractSyntaxMode {
  /** Accept all known storage SOP classes (default preset) */
  AllStorage = 'AllStorage',
  /** Accept any SOP class (promiscuous mode) */
  All = 'All',
  /** Accept only specified SOP classes */
  Custom = 'Custom'
}

/** * Combine multiple tag arrays into a single deduplicated array.
 *
 * Merges multiple arrays of tag names while removing duplicates,
 * preserving the order of first appearance. Useful for building
 * custom tag sets from predefined sets or combining modality-specific
 * tags with common tags.
 *
 * @param tagArrays - Array of tag name arrays to combine
 * @returns Single array containing all unique tag names
 *
 * @example
 * ```typescript
 * import { getCommonTagSets, combineTags } from '@nuxthealth/node-dicom';
 *
 * const tagSets = getCommonTagSets();
 *
 * // Combine multiple predefined sets
 * const combined = combineTags([
 *   tagSets.patientBasic,
 *   tagSets.studyBasic,
 *   tagSets.seriesBasic,
 *   tagSets.imagePixelInfo
 * ]);
 *
 * console.log(combined.length); // No duplicates
 * ```
 *
 * @example
 * ```typescript
 * // Mix predefined sets with custom tags
 * const tagSets = getCommonTagSets();
 *
 * const customTags = combineTags([
 *   tagSets.patientBasic,
 *   tagSets.studyBasic,
 *   ['CustomTag1', 'CustomTag2'],
 *   tagSets.ct,
 *   ['WindowCenter', 'WindowWidth'] // May overlap with other sets
 * ]);
 *
 * // Result contains all unique tags in order of first appearance
 * ```
 *
 * @example
 * ```typescript
 * // Build modality-agnostic tag set
 * const tagSets = getCommonTagSets();
 *
 * const universalModalityTags = combineTags([
 *   tagSets.default,
 *   tagSets.ct,
 *   tagSets.mr,
 *   tagSets.ultrasound,
 *   tagSets.petNm,
 *   tagSets.xa,
 *   tagSets.rt
 * ]);
 *
 * // Covers all modalities, duplicates automatically removed
 * console.log(`Total unique tags: ${universalModalityTags.length}`);
 * ```
 */
export declare function combineTags(tagArrays: Array<Array<string>>): Array<string>

/** * Predefined sets of commonly used DICOM tags organized by category.
 *
 * Provides convenient access to curated tag lists for different use cases,
 * eliminating the need to manually specify tags for common extraction scenarios.
 *
 * ## Tag Set Categories
 * - **patient_basic**: Essential patient demographics (name, ID, birth date, sex, age, weight, size)
 * - **study_basic**: Study-level metadata (UID, date, description, accession number, referring physician)
 * - **series_basic**: Series-level metadata (UID, number, description, modality, body part, protocol)
 * - **instance_basic**: Instance-level identifiers (SOP UIDs, instance number, creation date/time)
 * - **image_pixel_info**: Image dimensions and pixel characteristics (rows, columns, bits, spacing)
 * - **equipment**: Device information (manufacturer, model, serial number, software version, institution)
 * - **ct**: CT-specific imaging parameters (kVp, exposure, tube current, kernel, slice thickness)
 * - **mr**: MR-specific parameters (TR, TE, field strength, flip angle, scanning sequence)
 * - **ultrasound**: Ultrasound-specific tags (transducer type/frequency, sound path, frame time)
 * - **pet_nm**: PET/Nuclear Medicine tags (radiopharmaceutical info, dose, decay correction, units)
 * - **xa**: X-Ray Angiography tags (distances, intensifier size, positioner angles, radiation setting)
 * - **rt**: Radiation Therapy tags (RT image info, plan reference, gantry angle, beam info)
 * - **default**: Comprehensive set combining patient, study, series, instance, pixel info, and equipment
 *
 * @example
 * ```typescript
 * import { getCommonTagSets } from '@nuxthealth/node-dicom';
 *
 * // Get all predefined tag sets
 * const tagSets = getCommonTagSets();
 *
 * // Use specific tag set for extraction
 * const patientTags = tagSets.patientBasic;
 * // ['PatientName', 'PatientID', 'PatientBirthDate', ...]
 *
 * const studyTags = tagSets.studyBasic;
 * // ['StudyInstanceUID', 'StudyDate', 'StudyDescription', ...]
 *
 * // Combine multiple sets
 * const combinedTags = [
 *   ...tagSets.patientBasic,
 *   ...tagSets.studyBasic,
 *   ...tagSets.seriesBasic
 * ];
 *
 * // Or use the comprehensive default set
 * const allCommonTags = tagSets.default;
 * ```
 *
 * @example
 * ```typescript
 * // Modality-specific extraction
 * const tagSets = getCommonTagSets();
 *
 * // CT scan analysis
 * const ctTags = [
 *   ...tagSets.patientBasic,
 *   ...tagSets.studyBasic,
 *   ...tagSets.ct,
 *   ...tagSets.imagePixelInfo
 * ];
 *
 * // MR imaging
 * const mrTags = [
 *   ...tagSets.default,
 *   ...tagSets.mr
 * ];
 *
 * // PET/Nuclear Medicine
 * const petTags = [
 *   ...tagSets.default,
 *   ...tagSets.petNm
 * ];
 * ```
 */
export interface CommonTagSets {
  /** Essential patient demographics (7 tags: PatientName, PatientID, PatientBirthDate, PatientSex, PatientAge, PatientWeight, PatientSize) */
  patientBasic: Array<string>
  /** Study-level metadata (7 tags: StudyInstanceUID, StudyDate, StudyTime, StudyDescription, StudyID, AccessionNumber, ReferringPhysicianName) */
  studyBasic: Array<string>
  /** Series-level metadata (8 tags: SeriesInstanceUID, SeriesNumber, SeriesDescription, SeriesDate, SeriesTime, Modality, BodyPartExamined, ProtocolName) */
  seriesBasic: Array<string>
  /** Instance-level identifiers (5 tags: SOPInstanceUID, SOPClassUID, InstanceNumber, InstanceCreationDate, InstanceCreationTime) */
  instanceBasic: Array<string>
  /** Image dimensions and pixel characteristics (9 tags: Rows, Columns, BitsAllocated, BitsStored, HighBit, PixelRepresentation, SamplesPerPixel, PhotometricInterpretation, PixelSpacing) */
  imagePixelInfo: Array<string>
  /** Device and institution information (6 tags: Manufacturer, ManufacturerModelName, DeviceSerialNumber, SoftwareVersions, InstitutionName, StationName) */
  equipment: Array<string>
  /** CT-specific imaging parameters (6 tags: KVP, ExposureTime, XRayTubeCurrent, Exposure, ConvolutionKernel, SliceThickness) */
  ct: Array<string>
  /** MR-specific imaging parameters (6 tags: RepetitionTime, EchoTime, MagneticFieldStrength, FlipAngle, ImagingFrequency, ScanningSequence) */
  mr: Array<string>
  /** Ultrasound-specific tags (6 tags: TransducerType, TransducerFrequency, SoundPathLength, UltrasoundColorDataPresent, FrameTime, HeartRate) */
  ultrasound: Array<string>
  /** PET/Nuclear Medicine tags (11 tags: RadiopharmaceuticalInformationSequence, RadiopharmaceuticalStartTime, RadionuclideTotalDose, Units, DecayCorrection, etc.) */
  petNm: Array<string>
  /** X-Ray Angiography tags (8 tags: DistanceSourceToDetector, DistanceSourceToPatient, IntensifierSize, ImagerPixelSpacing, PositionerPrimaryAngle, etc.) */
  xa: Array<string>
  /** Radiation Therapy tags (11 tags: RTImageLabel, RTImageDescription, ReferencedRTPlanSequence, GantryAngle, BeamLimitingDeviceAngle, etc.) */
  rt: Array<string>
  /** Comprehensive default set combining patient_basic, study_basic, series_basic, instance_basic, image_pixel_info, and equipment (42 tags) */
  default: Array<string>
}

/** * Create a custom tag specification for extracting non-standard or private DICOM tags.
 *
 * Allows you to define custom mappings from DICOM tag numbers (in hex format)
 * to human-readable names. Useful for private tags, vendor-specific tags,
 * or tags not included in standard dictionaries.
 *
 * @param tag - DICOM tag in format "(GGGG,EEEE)" where GGGG is group and EEEE is element (hex)
 * @param name - Human-readable name to use for this tag in extracted data
 * @returns CustomTag object that can be used in extraction functions
 *
 * @example
 * ```typescript
 * import { createCustomTag, DicomFile } from '@nuxthealth/node-dicom';
 *
 * const dicom = new DicomFile();
 * dicom.open('scan-with-private-tags.dcm');
 *
 * // Define custom tags
 * const customTag1 = createCustomTag('(0009,1001)', 'VendorSpecificID');
 * const customTag2 = createCustomTag('(0019,100A)', 'ProprietaryField');
 *
 * // Extract using custom tag definitions
 * const data = dicom.extractWithCustomTags({
 *   tags: ['PatientName', 'StudyDate'],
 *   customTags: [customTag1, customTag2]
 * });
 *
 * console.log(data.VendorSpecificID);
 * console.log(data.ProprietaryField);
 * ```
 *
 * @example
 * ```typescript
 * // Extract private GE tags
 * const gePrivate1 = createCustomTag('(0009,10XX)', 'GE_PrivateCreator');
 * const gePrivate2 = createCustomTag('(0043,1001)', 'GE_ImageInfo');
 *
 * // Extract private Siemens tags
 * const siemensTag = createCustomTag('(0019,100C)', 'Siemens_ScanOptions');
 *
 * // Extract private Philips tags
 * const philipsTag = createCustomTag('(2001,1003)', 'Philips_ScanMode');
 * ```
 *
 * @example
 * ```typescript
 * // Build library of vendor-specific tags
 * const vendorTags = {
 *   ge: [
 *     createCustomTag('(0009,1001)', 'GE_Field1'),
 *     createCustomTag('(0043,1010)', 'GE_Field2')
 *   ],
 *   siemens: [
 *     createCustomTag('(0019,1008)', 'Siemens_Field1'),
 *     createCustomTag('(0029,1010)', 'Siemens_Field2')
 *   ],
 *   philips: [
 *     createCustomTag('(2001,1001)', 'Philips_Field1'),
 *     createCustomTag('(2005,1080)', 'Philips_Field2')
 *   ]
 * };
 *
 * // Use based on manufacturer
 * const manufacturer = dicom.extract(['Manufacturer'])[0];
 * const customTags = vendorTags[manufacturer.toLowerCase()] || [];
 * ```
 */
export declare function createCustomTag(tag: string, name: string): CustomTag

/** * Custom tag specification for extracting non-standard or private DICOM tags.
 *
 * Allows extraction of tags that aren't in the standard dictionary by specifying
 * the tag number directly. The extracted value will appear in the output using
 * your custom name instead of the raw tag number.
 *
 * ## Tag Format
 * Tags can be specified in multiple formats:
 * - Hex with parentheses: `(0010,0010)`
 * - Hex without parentheses: `00100010`
 * - Standard tag name: `PatientName` (if in dictionary)
 *
 * ## Output Location
 * Custom tags are grouped in a separate `custom` section in the output,
 * regardless of the grouping strategy used.
 *
 * @example
 * ```typescript
 * import { DicomFile, CustomTag } from '@nuxthealth/node-dicom';
 *
 * const dicom = new DicomFile();
 * dicom.open('scan-with-private-tags.dcm');
 *
 * // Define custom tags
 * const customTags: CustomTag[] = [
 *   { tag: '(0009,1001)', name: 'VendorID' },
 *   { tag: '(0019,100A)', name: 'ScannerMode' },
 *   { tag: '00091010', name: 'PrivateField' } // Without parentheses
 * ];
 *
 * // Extract with custom tags
 * const data = dicom.extract(
 *   ['PatientName', 'StudyDate'],
 *   customTags,
 *   'ByScope'
 * );
 *
 * console.log(JSON.parse(data));
 * // {
 * //   patient: { PatientName: 'DOE^JOHN' },
 * //   study: { StudyDate: '20240101' },
 * //   custom: {
 * //     VendorID: 'GE_MED',
 * //     ScannerMode: 'HELICAL',
 * //     PrivateField: 'value'
 * //   }
 * // }
 * ```
 *
 * @example
 * ```typescript
 * // Vendor-specific private tags
 *
 * // GE Medical Systems
 * const geTags: CustomTag[] = [
 *   { tag: '(0009,1001)', name: 'GE_PrivateCreator' },
 *   { tag: '(0043,1010)', name: 'GE_ImageType' }
 * ];
 *
 * // Siemens
 * const siemensTags: CustomTag[] = [
 *   { tag: '(0019,1008)', name: 'Siemens_CSAImageHeader' },
 *   { tag: '(0029,1010)', name: 'Siemens_CSASeriesHeader' }
 * ];
 *
 * // Philips
 * const philipsTags: CustomTag[] = [
 *   { tag: '(2001,1001)', name: 'Philips_ImageType' },
 *   { tag: '(2005,1080)', name: 'Philips_ReconstructionNumber' }
 * ];
 * ```
 *
 * @example
 * ```typescript
 * // Extract both standard and custom tags
 * import { getCommonTagSets } from '@nuxthealth/node-dicom';
 *
 * const tagSets = getCommonTagSets();
 * const dicom = new DicomFile();
 * dicom.open('scan.dcm');
 *
 * const customTags: CustomTag[] = [
 *   { tag: '(0009,1001)', name: 'PrivateTag1' },
 *   { tag: '(0019,100A)', name: 'PrivateTag2' }
 * ];
 *
 * // Combine standard and custom extraction
 * const data = dicom.extract(
 *   tagSets.default, // All standard tags
 *   customTags,      // Plus custom private tags
 *   'ByScope'
 * );
 * ```
 */
export interface CustomTag {
  /** The tag in hex format (e.g., "(0010,0010)" or "00100010") or tag name */
  tag: string
  /** User-defined name for this tag in the output (appears in 'custom' section) */
  name: string
}

export interface DicomFileMeta {
  /** Storage SOP Class UID */
  sopClassUid: string
  /** Storage SOP Instance UID */
  sopInstanceUid: string
}

/** * Event data for OnFileError event.
 *
 * Emitted when an error occurs while sending a file.
 */
export interface FileErrorEvent {
  message: string
  file: string
  error: string
  sopInstanceUid?: string
  sopClassUid?: string
  fileTransferSyntax?: string
}

/** * Event data for OnFileSending event.
 *
 * Emitted when a file is about to be sent.
 */
export interface FileSendingEvent {
  message: string
  file: string
  sopInstanceUid: string
  sopClassUid: string
}

/** * Event data for OnFileSent event.
 *
 * Emitted when a file has been successfully sent.
 */
export interface FileSentEvent {
  message: string
  file: string
  sopInstanceUid: string
  sopClassUid: string
  transferSyntax: string
  durationSeconds: number
}

/** * Get a comprehensive list of 300+ commonly used DICOM tag names.
 *
 * Returns an array of standard DICOM tag names covering all major
 * modalities and use cases. These names can be used directly with
 * extraction functions like `extract()`, `extractBatch()`, etc.
 *
 * The list includes tags from all categories:
 * - Patient demographics and identification
 * - Study, series, and instance metadata
 * - Image characteristics and pixel data
 * - Equipment and institution information
 * - Modality-specific parameters (CT, MR, US, PET, NM, XA, RT, etc.)
 * - Timing and temporal information
 * - Geometry and spatial information
 * - Display and presentation parameters
 * - Technical acquisition parameters
 * - Overlays, graphics, and waveforms
 * - Multi-frame and cine sequences
 *
 * @returns Array of 300+ standard DICOM tag names
 *
 * @example
 * ```typescript
 * import { getAvailableTagNames } from '@nuxthealth/node-dicom';
 *
 * // Get all available tag names
 * const allTags = getAvailableTagNames();
 * console.log(`Total available tags: ${allTags.length}`);
 * // Output: Total available tags: 300+
 *
 * // Check if specific tag is available
 * const hasWindowCenter = allTags.includes('WindowCenter');
 * const hasCustomTag = allTags.includes('MyCustomTag');
 *
 * // Use for autocomplete or validation
 * const validTags = ['PatientName', 'StudyDate', 'InvalidTag']
 *   .filter(tag => allTags.includes(tag));
 * ```
 *
 * @example
 * ```typescript
 * // Search for tags matching a pattern
 * const allTags = getAvailableTagNames();
 *
 * // Find all patient-related tags
 * const patientTags = allTags.filter(tag =>
 *   tag.toLowerCase().includes('patient')
 * );
 * console.log(patientTags);
 * // ['PatientName', 'PatientID', 'PatientBirthDate', ...]
 *
 * // Find all timing-related tags
 * const timeTags = allTags.filter(tag =>
 *   tag.includes('Time') || tag.includes('Date')
 * );
 *
 * // Find all UID tags
 * const uidTags = allTags.filter(tag => tag.endsWith('UID'));
 * ```
 *
 * @example
 * ```typescript
 * // Build dynamic tag selection UI
 * const allTags = getAvailableTagNames();
 *
 * // Group tags by category
 * const tagsByCategory = {
 *   patient: allTags.filter(t => t.includes('Patient')),
 *   study: allTags.filter(t => t.includes('Study')),
 *   series: allTags.filter(t => t.includes('Series')),
 *   image: allTags.filter(t => t.includes('Image') || t.includes('Pixel')),
 *   equipment: allTags.filter(t =>
 *     t.includes('Manufacturer') ||
 *     t.includes('Device') ||
 *     t.includes('Station')
 *   )
 * };
 *
 * // Present to user for selection
 * Object.entries(tagsByCategory).forEach(([category, tags]) => {
 *   console.log(`${category}: ${tags.length} tags available`);
 * });
 * ```
 *
 * @example
 * ```typescript
 * // Validate user input against available tags
 * const allTags = getAvailableTagNames();
 *
 * function validateTagNames(userTags: string[]): {
 *   valid: string[],
 *   invalid: string[]
 * } {
 *   const valid = userTags.filter(tag => allTags.includes(tag));
 *   const invalid = userTags.filter(tag => !allTags.includes(tag));
 *   return { valid, invalid };
 * }
 *
 * const userInput = [
 *   'PatientName',
 *   'StudyDate',
 *   'InvalidTag',
 *   'Modality'
 * ];
 *
 * const result = validateTagNames(userInput);
 * console.log('Valid tags:', result.valid);
 * console.log('Invalid tags:', result.invalid);
 * ```
 */
export declare function getAvailableTagNames(): Array<'AccessionNumber' | 'AcquisitionDate' | 'AcquisitionDateTime' | 'AcquisitionNumber' | 'AcquisitionTime' | 'ActualCardiacTriggerTimePriorToRPeak' | 'ActualFrameDuration' | 'AdditionalPatientHistory' | 'AdmissionID' | 'AdmittingDiagnosesDescription' | 'AnatomicalOrientationType' | 'AnatomicRegionSequence' | 'AnodeTargetMaterial' | 'BeamLimitingDeviceAngle' | 'BitsAllocated' | 'BitsStored' | 'BluePaletteColorLookupTableDescriptor' | 'BodyPartExamined' | 'BodyPartThickness' | 'BranchOfService' | 'BurnedInAnnotation' | 'ChannelSensitivity' | 'CineRate' | 'CollimatorType' | 'Columns' | 'CompressionForce' | 'ContentDate' | 'ContentTime' | 'ContrastBolusAgent' | 'ContrastBolusIngredient' | 'ContrastBolusIngredientConcentration' | 'ContrastBolusRoute' | 'ContrastBolusStartTime' | 'ContrastBolusStopTime' | 'ContrastBolusTotalDose' | 'ContrastBolusVolume' | 'ContrastFlowDuration' | 'ContrastFlowRate' | 'ConvolutionKernel' | 'CorrectedImage' | 'CountsSource' | 'DataCollectionDiameter' | 'DecayCorrection' | 'DeidentificationMethod' | 'DerivationDescription' | 'DetectorTemperature' | 'DeviceSerialNumber' | 'DistanceSourceToDetector' | 'DistanceSourceToPatient' | 'EchoTime' | 'EthnicGroup' | 'Exposure' | 'ExposureInMicroAmpereSeconds' | 'ExposureTime' | 'FilterType' | 'FlipAngle' | 'FocalSpots' | 'FrameDelay' | 'FrameIncrementPointer' | 'FrameOfReferenceUID' | 'FrameTime' | 'GantryAngle' | 'GeneratorPower' | 'GraphicAnnotationSequence' | 'GreenPaletteColorLookupTableDescriptor' | 'HeartRate' | 'HighBit' | 'ImageComments' | 'ImageLaterality' | 'ImageOrientationPatient' | 'ImagePositionPatient' | 'ImagerPixelSpacing' | 'ImageTriggerDelay' | 'ImageType' | 'ImagingFrequency' | 'ImplementationClassUID' | 'ImplementationVersionName' | 'InstanceCreationDate' | 'InstanceCreationTime' | 'InstanceNumber' | 'InstitutionName' | 'IntensifierSize' | 'IssuerOfAdmissionID' | 'KVP' | 'LargestImagePixelValue' | 'LargestPixelValueInSeries' | 'Laterality' | 'LossyImageCompression' | 'LossyImageCompressionMethod' | 'LossyImageCompressionRatio' | 'MagneticFieldStrength' | 'Manufacturer' | 'ManufacturerModelName' | 'MedicalRecordLocator' | 'MilitaryRank' | 'Modality' | 'MultiplexGroupTimeOffset' | 'NameOfPhysiciansReadingStudy' | 'NominalCardiacTriggerDelayTime' | 'NominalInterval' | 'NumberOfFrames' | 'NumberOfSlices' | 'NumberOfTemporalPositions' | 'NumberOfWaveformChannels' | 'NumberOfWaveformSamples' | 'Occupation' | 'OperatorsName' | 'OtherPatientIDs' | 'OtherPatientNames' | 'OverlayBitPosition' | 'OverlayBitsAllocated' | 'OverlayColumns' | 'OverlayData' | 'OverlayOrigin' | 'OverlayRows' | 'OverlayType' | 'PaddleDescription' | 'PatientAge' | 'PatientBirthDate' | 'PatientBreedDescription' | 'PatientComments' | 'PatientID' | 'PatientIdentityRemoved' | 'PatientName' | 'PatientPosition' | 'PatientSex' | 'PatientSize' | 'PatientSpeciesDescription' | 'PatientSupportAngle' | 'PatientTelephoneNumbers' | 'PatientWeight' | 'PerformedProcedureStepDescription' | 'PerformedProcedureStepID' | 'PerformedProcedureStepStartDate' | 'PerformedProcedureStepStartTime' | 'PerformedProtocolCodeSequence' | 'PerformingPhysicianName' | 'PhotometricInterpretation' | 'PhysiciansOfRecord' | 'PixelAspectRatio' | 'PixelPaddingRangeLimit' | 'PixelPaddingValue' | 'PixelRepresentation' | 'PixelSpacing' | 'PlanarConfiguration' | 'PositionerPrimaryAngle' | 'PositionerSecondaryAngle' | 'PositionReferenceIndicator' | 'PreferredPlaybackSequencing' | 'PresentationIntentType' | 'PresentationLUTShape' | 'PrimaryAnatomicStructureSequence' | 'PrivateInformationCreatorUID' | 'ProtocolName' | 'QualityControlImage' | 'RadiationMachineName' | 'RadiationSetting' | 'RadionuclideTotalDose' | 'RadiopharmaceuticalInformationSequence' | 'RadiopharmaceuticalStartDateTime' | 'RadiopharmaceuticalStartTime' | 'RadiopharmaceuticalVolume' | 'ReasonForTheRequestedProcedure' | 'ReceivingApplicationEntityTitle' | 'RecognizableVisualFeatures' | 'RecommendedDisplayFrameRate' | 'ReconstructionDiameter' | 'ReconstructionTargetCenterPatient' | 'RedPaletteColorLookupTableDescriptor' | 'ReferencedBeamNumber' | 'ReferencedImageSequence' | 'ReferencedPatientPhotoSequence' | 'ReferencedPerformedProcedureStepSequence' | 'ReferencedRTPlanSequence' | 'ReferencedSOPClassUID' | 'ReferencedSOPInstanceUID' | 'ReferencedStudySequence' | 'ReferringPhysicianName' | 'RepetitionTime' | 'RequestAttributesSequence' | 'RequestedContrastAgent' | 'RequestedProcedureDescription' | 'RequestedProcedureID' | 'RequestingPhysician' | 'RescaleIntercept' | 'RescaleSlope' | 'RescaleType' | 'ResponsibleOrganization' | 'ResponsiblePerson' | 'ResponsiblePersonRole' | 'Rows' | 'RTImageDescription' | 'RTImageLabel' | 'SamplesPerPixel' | 'SamplingFrequency' | 'ScanningSequence' | 'SendingApplicationEntityTitle' | 'SeriesDate' | 'SeriesDescription' | 'SeriesInstanceUID' | 'SeriesNumber' | 'SeriesTime' | 'SeriesType' | 'SliceLocation' | 'SliceThickness' | 'SmallestImagePixelValue' | 'SmallestPixelValueInSeries' | 'SoftwareVersions' | 'SOPClassUID' | 'SOPInstanceUID' | 'SoundPathLength' | 'SourceApplicationEntityTitle' | 'SourceImageSequence' | 'SpacingBetweenSlices' | 'SpecificCharacterSet' | 'StationName' | 'StudyComments' | 'StudyDate' | 'StudyDescription' | 'StudyID' | 'StudyInstanceUID' | 'StudyTime' | 'TableHeight' | 'TableTopLateralPosition' | 'TableTopLongitudinalPosition' | 'TableTopVerticalPosition' | 'TableType' | 'TemporalPositionIdentifier' | 'TemporalResolution' | 'TextObjectSequence' | 'TimezoneOffsetFromUTC' | 'TransducerFrequency' | 'TransducerType' | 'TransferSyntaxUID' | 'TriggerTime' | 'TriggerTimeOffset' | 'UltrasoundColorDataPresent' | 'Units' | 'VOILUTFunction' | 'WaveformOriginality' | 'WaveformSequence' | 'WindowCenter' | 'WindowCenterWidthExplanation' | 'WindowWidth' | 'XRayTubeCurrent'>

/** * Get a list of common SOP Class UIDs (Abstract Syntaxes).
 *
 * Use these to configure which types of DICOM objects your SCP accepts.
 *
 * @returns Object containing categorized SOP Class UID lists
 *
 * @example
 * ```typescript
 * import { StoreScp, getCommonSopClasses } from '@nuxthealth/node-dicom';
 *
 * const sopClasses = getCommonSopClasses();
 *
 * // Accept only CT and MR images
 * const scp = new StoreScp({
 *   port: 11111,
 *   abstractSyntaxMode: 'Custom',
 *   abstractSyntaxes: [...sopClasses.ct, ...sopClasses.mr]
 * });
 *
 * // Accept all imaging modalities
 * const scp2 = new StoreScp({
 *   port: 11112,
 *   abstractSyntaxMode: 'Custom',
 *   abstractSyntaxes: sopClasses.allImaging
 * });
 * ```
 */
export declare function getCommonSopClasses(): SopClassConfig

/** * Get predefined sets of commonly used DICOM tags organized by category.
 *
 * Returns a structured object containing 13 different tag sets for various
 * use cases, from basic patient demographics to modality-specific parameters.
 *
 * This is the primary function for accessing curated tag lists without
 * needing to manually specify individual tag names.
 *
 * @returns Object containing all predefined tag sets
 *
 * @example
 * ```typescript
 * import { getCommonTagSets, DicomFile } from '@nuxthealth/node-dicom';
 *
 * const dicom = new DicomFile();
 * dicom.open('patient-scan.dcm');
 *
 * // Get all tag sets
 * const tagSets = getCommonTagSets();
 *
 * // Extract patient demographics
 * const patientData = dicom.extract(tagSets.patientBasic);
 * console.log(patientData);
 * // { PatientName: 'DOE^JOHN', PatientID: '12345', ... }
 *
 * // Extract study information
 * const studyData = dicom.extract(tagSets.studyBasic);
 *
 * // Extract everything common
 * const allData = dicom.extract(tagSets.default);
 * ```
 *
 * @example
 * ```typescript
 * // Modality-specific workflows
 * const tagSets = getCommonTagSets();
 * const dicom = new DicomFile();
 * dicom.open('ct-scan.dcm');
 *
 * // CT scan: combine common tags with CT-specific parameters
 * const ctTags = [
 *   ...tagSets.default,
 *   ...tagSets.ct
 * ];
 * const ctData = dicom.extract(ctTags);
 * console.log(ctData.KVP, ctData.ConvolutionKernel);
 *
 * // MR scan: different parameter set
 * const mrTags = [...tagSets.default, ...tagSets.mr];
 * const mrData = dicom.extract(mrTags);
 * console.log(mrData.RepetitionTime, mrData.EchoTime);
 * ```
 *
 * @example
 * ```typescript
 * // Build custom tag set for specific workflow
 * const tagSets = getCommonTagSets();
 *
 * // Anonymization workflow: extract metadata but exclude patient info
 * const metadataOnlyTags = [
 *   ...tagSets.studyBasic,
 *   ...tagSets.seriesBasic,
 *   ...tagSets.instanceBasic,
 *   ...tagSets.imagePixelInfo,
 *   ...tagSets.equipment
 * ];
 *
 * // PACS routing: minimal required tags
 * const routingTags = [
 *   ...tagSets.patientBasic,
 *   ...tagSets.studyBasic,
 *   'Modality',
 *   'SOPClassUID'
 * ];
 * ```
 */
export declare function getCommonTagSets(): CommonTagSets

/** * Get a list of common Transfer Syntax UIDs.
 *
 * Use these to configure which encodings/compressions your SCP accepts.
 *
 * @returns Object containing categorized Transfer Syntax UID lists
 *
 * @example
 * ```typescript
 * import { StoreScp, getCommonTransferSyntaxes } from '@nuxthealth/node-dicom';
 *
 * const transferSyntaxes = getCommonTransferSyntaxes();
 *
 * // Accept uncompressed and JPEG only
 * const scp = new StoreScp({
 *   port: 11111,
 *   transferSyntaxMode: 'Custom',
 *   transferSyntaxes: [...transferSyntaxes.uncompressed, ...transferSyntaxes.jpeg]
 * });
 * ```
 */
export declare function getCommonTransferSyntaxes(): TransferSyntaxConfig

/** * Grouping strategy for organizing extracted DICOM tag data.
 *
 * Determines how extracted tags are structured in the output JSON.
 * Different strategies are useful for different workflows and data processing needs.
 *
 * ## Strategy Types
 *
 * ### ByScope
 * Groups tags by DICOM hierarchy level:
 * - `patient`: Patient demographics (PatientName, PatientID, etc.)
 * - `study`: Study-level metadata (StudyInstanceUID, StudyDate, etc.)
 * - `series`: Series-level metadata (SeriesInstanceUID, Modality, etc.)
 * - `instance`: Instance-level data (SOPInstanceUID, InstanceNumber, etc.)
 * - `equipment`: Device information (Manufacturer, StationName, etc.)
 * - `custom`: User-defined custom tags
 *
 * Best for: DICOM-aware applications, PACS systems, hierarchical data processing
 *
 * ### Flat
 * All tags at the root level without grouping.
 *
 * Best for: Simple key-value access, database insertion, quick lookups
 *
 * ### StudyLevel
 * Groups tags into two levels:
 * - `studyLevel`: Patient + Study tags (persists across all instances)
 * - `instanceLevel`: Series + Instance + Equipment tags (varies per file)
 *
 * Best for: Study-based processing, deduplication, study aggregation
 *
 * ### Custom
 * User-defined grouping rules (currently defaults to ByScope).
 *
 * Best for: Future extensibility with custom grouping logic
 *
 * @example
 * ```typescript
 * import { DicomFile } from '@nuxthealth/node-dicom';
 *
 * const dicom = new DicomFile();
 * dicom.open('scan.dcm');
 *
 * // ByScope strategy (hierarchical)
 * const scoped = dicom.extract(
 *   ['PatientName', 'StudyDate', 'Modality', 'SOPInstanceUID'],
 *   undefined,
 *   'ByScope'
 * );
 * console.log(JSON.parse(scoped));
 * // {
 * //   patient: { PatientName: 'DOE^JOHN' },
 * //   study: { StudyDate: '20240101' },
 * //   series: { Modality: 'CT' },
 * //   instance: { SOPInstanceUID: '1.2.3.4...' }
 * // }
 *
 * // Flat strategy (simple)
 * const flat = dicom.extract(
 *   ['PatientName', 'StudyDate', 'Modality'],
 *   undefined,
 *   'Flat'
 * );
 * console.log(JSON.parse(flat));
 * // {
 * //   PatientName: 'DOE^JOHN',
 * //   StudyDate: '20240101',
 * //   Modality: 'CT'
 * // }
 *
 * // StudyLevel strategy (two-tier)
 * const studyLevel = dicom.extract(
 *   ['PatientName', 'StudyDate', 'SeriesNumber', 'InstanceNumber'],
 *   undefined,
 *   'StudyLevel'
 * );
 * console.log(JSON.parse(studyLevel));
 * // {
 * //   studyLevel: { PatientName: 'DOE^JOHN', StudyDate: '20240101' },
 * //   instanceLevel: { SeriesNumber: '1', InstanceNumber: '1' }
 * // }
 * ```
 *
 * @example
 * ```typescript
 * // Practical use cases
 *
 * // PACS integration (ByScope)
 * const pacsData = dicom.extract(
 *   ['PatientID', 'StudyInstanceUID', 'SeriesInstanceUID', 'SOPInstanceUID'],
 *   undefined,
 *   'ByScope'
 * );
 *
 * // Database insertion (Flat)
 * const dbData = dicom.extract(
 *   ['PatientID', 'StudyDate', 'Modality', 'FilePath'],
 *   undefined,
 *   'Flat'
 * );
 * // Can directly map to database columns
 *
 * // Study deduplication (StudyLevel)
 * const dedupeData = dicom.extract(
 *   ['PatientID', 'StudyInstanceUID', 'SeriesInstanceUID', 'SOPInstanceUID'],
 *   undefined,
 *   'StudyLevel'
 * );
 * // studyLevel contains study key, instanceLevel contains file-specific data
 * ```
 */
export declare const enum GroupingStrategy {
  /** Group by DICOM hierarchy scope (Patient, Study, Series, Instance, Equipment) */
  ByScope = 'ByScope',
  /** Flat structure with all tags at root level */
  Flat = 'Flat',
  /** Group into studyLevel (Patient+Study) and instanceLevel (Series+Instance+Equipment) */
  StudyLevel = 'StudyLevel',
  /** Custom grouping rules (user provides mapping) */
  Custom = 'Custom'
}

/** Instance (file) data within a series */
export interface InstanceHierarchyData {
  sopInstanceUid: string
  sopClassUid: string
  transferSyntaxUid: string
  file: string
  tagsScoped?: ScopedDicomData
  tagsFlat?: Record<string, string>
  tagsStudyLevel?: StudyLevelData
}

/** Output format for pixel data */
export declare const enum PixelDataFormat {
  /** Raw binary data (no processing) */
  Raw = 'Raw',
  /** PNG image (requires decode=true) */
  Png = 'Png',
  /** JPEG image (requires decode=true) */
  Jpeg = 'Jpeg',
  /** JSON metadata about pixel data */
  Json = 'Json'
}

/** Pixel data information */
export interface PixelDataInfo {
  /** Width in pixels */
  width: number
  /** Height in pixels */
  height: number
  /** Number of frames */
  frames: number
  /** Bits allocated per pixel */
  bitsAllocated: number
  /** Bits stored per pixel */
  bitsStored: number
  /** High bit */
  highBit: number
  /** Pixel representation (0=unsigned, 1=signed) */
  pixelRepresentation: number
  /** Samples per pixel (1=grayscale, 3=RGB) */
  samplesPerPixel: number
  /** Photometric interpretation */
  photometricInterpretation: string
  /** Transfer syntax UID */
  transferSyntaxUid: string
  /** Whether pixel data is compressed */
  isCompressed: boolean
  /** Total pixel data size in bytes */
  dataSize: number
  /** Rescale intercept (for Hounsfield units in CT) */
  rescaleIntercept?: number
  /** Rescale slope */
  rescaleSlope?: number
  /** Window center from file */
  windowCenter?: number
  /** Window width from file */
  windowWidth?: number
}

/** Options for pixel data processing */
export interface PixelDataOptions {
  /** Output file path */
  outputPath: string
  /** Output format */
  format?: PixelDataFormat
  /** Decode/decompress pixel data (requires transcode feature) */
  decode?: boolean
  /** Convert to 8-bit grayscale (requires decode=true) */
  convertTo8Bit?: boolean
  /** Apply VOI LUT (Value of Interest Lookup Table) for windowing */
  applyVoiLut?: boolean
  /** Window center for manual windowing (overrides VOI LUT from file) */
  windowCenter?: number
  /** Window width for manual windowing (overrides VOI LUT from file) */
  windowWidth?: number
  /** Frame number to extract (0-based, for multi-frame images) */
  frameNumber?: number
  /** Extract all frames as separate files (output_path will be used as template: path_{frame}.ext) */
  extractAllFrames?: boolean
}

/** * Result of a DICOM transfer operation.
 *
 * Returned by the `send()` method to indicate the outcome of the transfer.
 *
 * @example
 * ```typescript
 * const results = await scu.send();
 * for (const result of results) {
 *   if (result.status === 'Success') {
 *     console.log('✓', result.message);
 *   } else {
 *     console.error('✗', result.message);
 *   }
 * }
 * ```
 */
export interface ResultObject {
  /** Status of the transfer operation */
  status: ResultStatus
  /** Descriptive message about the result */
  message: string
}

/** * Status of a DICOM transfer operation.
 *
 * Indicates whether the transfer completed successfully or encountered an error.
 */
export declare const enum ResultStatus {
  /** Transfer completed successfully */
  Success = 'Success',
  /** Transfer failed with an error */
  Error = 'Error'
}

/** S3 storage configuration */
export interface S3Config {
  /** S3 bucket name */
  bucket: string
  /** AWS access key ID */
  accessKey: string
  /** AWS secret access key */
  secretKey: string
  /** S3 endpoint (e.g., "http://localhost:9000" for MinIO) */
  endpoint?: string
}

/** * Standalone utility to extract raw pixel data from a DICOM file.
 *
 * This is a convenience function that opens a DICOM file, extracts the raw pixel data,
 * and saves it to a file in a single operation. For repeated operations on the same file,
 * prefer using the DicomFile class with `open()` and `saveRawPixelData()`.
 *
 * @param filePath - Path to the source DICOM file
 * @param outPath - Path where the raw pixel data will be saved
 * @returns Success message with the number of bytes written
 * @throws Error if the file cannot be opened, pixel data is missing, or write fails
 *
 * @example
 * ```typescript
 * import { saveRawPixelData } from '@nuxthealth/node-dicom';
 *
 * saveRawPixelData('/path/to/image.dcm', '/path/to/output.raw');
 * ```
 */
export declare function saveRawPixelData(filePath: string, outPath: string): string

/** * DICOM data extracted and grouped by hierarchy scope.
 *
 * Result structure when using `GroupingStrategy.ByScope`.
 * Tags are organized into sections based on their DICOM hierarchy level.
 * Empty sections are omitted from the output.
 *
 * ## Hierarchy Levels
 * - **patient**: Patient demographics and identification
 * - **study**: Study-level metadata and workflow info
 * - **series**: Series-level imaging parameters
 * - **instance**: Instance-specific data (per image/file)
 * - **equipment**: Device and acquisition equipment info
 * - **custom**: User-defined custom/private tags
 *
 * @example
 * ```typescript
 * import { DicomFile, ScopedDicomData } from '@nuxthealth/node-dicom';
 *
 * const dicom = new DicomFile();
 * dicom.open('ct-scan.dcm');
 *
 * const json = dicom.extract(
 *   ['PatientName', 'PatientID', 'StudyDate', 'Modality', 'SOPInstanceUID'],
 *   undefined,
 *   'ByScope'
 * );
 *
 * const data: ScopedDicomData = JSON.parse(json);
 *
 * // Access by hierarchy level
 * if (data.patient) {
 *   console.log('Patient:', data.patient.PatientName);
 *   console.log('ID:', data.patient.PatientID);
 * }
 *
 * if (data.study) {
 *   console.log('Study Date:', data.study.StudyDate);
 * }
 *
 * if (data.series) {
 *   console.log('Modality:', data.series.Modality);
 * }
 *
 * if (data.instance) {
 *   console.log('SOP UID:', data.instance.SOPInstanceUID);
 * }
 * ```
 *
 * @example
 * ```typescript
 * // Type-safe processing
 * interface PatientInfo {
 *   PatientName?: string;
 *   PatientID?: string;
 *   PatientBirthDate?: string;
 * }
 *
 * interface StudyInfo {
 *   StudyInstanceUID?: string;
 *   StudyDate?: string;
 *   StudyDescription?: string;
 * }
 *
 * const data: ScopedDicomData = JSON.parse(json);
 *
 * const patient = data.patient as PatientInfo | undefined;
 * const study = data.study as StudyInfo | undefined;
 *
 * if (patient?.PatientID && study?.StudyInstanceUID) {
 *   // Process study for this patient
 *   console.log(`Patient ${patient.PatientID}: Study ${study.StudyInstanceUID}`);
 * }
 * ```
 */
export interface ScopedDicomData {
  /** Patient-level tags (demographics, identification) */
  patient?: Record<string, string>
  /** Study-level tags (study metadata, workflow) */
  study?: Record<string, string>
  /** Series-level tags (series metadata, imaging parameters) */
  series?: Record<string, string>
  /** Instance-level tags (per-image/file data) */
  instance?: Record<string, string>
  /** Equipment-level tags (device, manufacturer info) */
  equipment?: Record<string, string>
  /** Custom/private tags with user-defined names */
  custom?: Record<string, string>
}

/** * Event data passed to event listeners.
 *
 * Contains information about the event that occurred.
 */
export interface ScpEventData {
  /** Human-readable message describing the event */
  message: string
  /** Optional event-specific details */
  data?: ScpEventDetails
}

/** Details about SCP events with typed tag extraction */
export interface ScpEventDetails {
  /** File path where DICOM file was stored */
  file?: string
  /** SOP Instance UID */
  sopInstanceUid?: string
  /** SOP Class UID */
  sopClassUid?: string
  /** Transfer Syntax UID */
  transferSyntaxUid?: string
  /** Study Instance UID */
  studyInstanceUid?: string
  /** Series Instance UID */
  seriesInstanceUid?: string
  /** Extracted DICOM tags (structured based on grouping strategy) */
  tagsScoped?: ScopedDicomData
  /** Extracted DICOM tags (flat key-value pairs) */
  tagsFlat?: Record<string, string>
  /** Extracted DICOM tags (study-level grouping) */
  tagsStudyLevel?: StudyLevelData
  /** Error message (for OnError events) */
  error?: string
  /** Study completion data with full hierarchy */
  study?: StudyHierarchyData
}

/** Series data within a study */
export interface SeriesHierarchyData {
  seriesInstanceUid: string
  tagsScoped?: ScopedDicomData
  tagsFlat?: Record<string, string>
  tagsStudyLevel?: StudyLevelData
  instances: Array<InstanceHierarchyData>
}

/** SOP Class configuration object */
export interface SopClassConfig {
  /** CT imaging SOP classes */
  ct: Array<string>
  /** MR imaging SOP classes */
  mr: Array<string>
  /** Ultrasound imaging SOP classes */
  ultrasound: Array<string>
  /** PET and nuclear medicine SOP classes */
  pet: Array<string>
  /** X-Ray and CR imaging SOP classes */
  xray: Array<string>
  /** Mammography SOP classes */
  mammography: Array<string>
  /** Secondary capture SOP classes */
  secondaryCapture: Array<string>
  /** Radiation therapy SOP classes */
  radiationTherapy: Array<string>
  /** Document and presentation SOP classes */
  documents: Array<string>
  /** Structured report SOP classes */
  structuredReports: Array<string>
  /** All imaging modalities (CT, MR, US, PET, XR) */
  allImaging: Array<string>
  /** All storage SOP classes */
  all: Array<string>
}

/** Storage backend type */
export declare const enum StorageBackend {
  /** Local filesystem storage */
  Filesystem = 'Filesystem',
  /** S3-compatible object storage */
  S3 = 'S3'
}

/** * Storage backend type for DICOM C-STORE SCP.
 *
 * Determines where incoming DICOM files will be stored.
 *
 * @example
 * ```typescript
 * // Use filesystem storage
 * const scp = new StoreScp({
 *   port: 11111,
 *   storageBackend: 'Filesystem',
 *   outDir: './dicom-data'
 * });
 *
 * // Use S3 storage
 * const scpS3 = new StoreScp({
 *   port: 11111,
 *   storageBackend: 'S3',
 *   s3Config: {
 *     bucket: 'my-dicom-bucket',
 *     accessKey: 'ACCESS_KEY',
 *     secretKey: 'SECRET_KEY',
 *     endpoint: 'http://localhost:9000'
 *   }
 * });
 * ```
 */
export declare const enum StorageBackendType {
  /** Store files on local filesystem */
  Filesystem = 'Filesystem',
  /** Store files in S3-compatible object storage */
  S3 = 'S3'
}

/** Storage configuration for DicomFile */
export interface StorageConfig {
  /** Storage backend type */
  backend: StorageBackend
  /** Root directory for filesystem storage (relative or absolute path) */
  rootDir?: string
  /** S3 configuration (required if backend is S3) */
  s3Config?: S3Config
}

/** * Events emitted by the DICOM C-STORE SCP server.
 *
 * Use these events to monitor server activity and handle incoming DICOM files.
 *
 * @example
 * ```typescript
 * const scp = new StoreScp({ port: 11111 });
 *
 * scp.addEventListener('OnServerStarted', (data) => {
 *   console.log('Server started:', data.message);
 * });
 *
 * scp.addEventListener('OnFileStored', (data) => {
 *   const fileInfo = JSON.parse(data.data!);
 *   console.log('File stored:', fileInfo.sopInstanceUid);
 * });
 *
 * scp.addEventListener('OnStudyCompleted', (data) => {
 *   const studyInfo = JSON.parse(data.data!);
 *   console.log('Study completed:', studyInfo);
 * });
 * ```
 */
export declare const enum StoreScpEvent {
  /** Server has started and is listening for connections */
  OnServerStarted = 'OnServerStarted',
  /** An error occurred during file storage or processing */
  OnError = 'OnError',
  /** A new DICOM connection has been established */
  OnConnection = 'OnConnection',
  /** A DICOM file has been successfully stored */
  OnFileStored = 'OnFileStored',
  /** A complete study (all files) has been received and stored */
  OnStudyCompleted = 'OnStudyCompleted'
}

/** * Configuration options for the DICOM C-STORE SCP server.
 *
 * @example
 * ```typescript
 * // Basic filesystem storage
 * const options1: StoreScpOptions = {
 *   port: 11111,
 *   outDir: './dicom-storage',
 *   verbose: true
 * };
 *
 * // S3 storage with tag extraction
 * const options2: StoreScpOptions = {
 *   port: 11111,
 *   storageBackend: 'S3',
 *   s3Config: {
 *     bucket: 'dicom-bucket',
 *     accessKey: 'ACCESS_KEY',
 *     secretKey: 'SECRET_KEY',
 *     endpoint: 'http://localhost:9000'
 *   },
 *   extractTags: ['PatientName', 'StudyDate', 'Modality'],
 *   groupingStrategy: 'ByScope',
 *   studyTimeout: 60
 * };
 *
 * // Strict mode with uncompressed only
 * const options3: StoreScpOptions = {
 *   port: 11111,
 *   callingAeTitle: 'MY-SCP',
 *   strict: true,
 *   uncompressedOnly: true,
 *   maxPduLength: 32768
 * };
 * ```
 */
export interface StoreScpOptions {
  /** Enable verbose logging (default: false) */
  verbose?: boolean
  /** Application Entity title for this SCP (default: "STORE-SCP") */
  callingAeTitle?: string
  /** Enforce strict PDU length limits (default: false) */
  strict?: boolean
  /** Maximum PDU length in bytes (default: 16384) */
  maxPduLength?: number
  /** Abstract syntax (SOP Class) acceptance mode (default: 'AllStorage') */
  abstractSyntaxMode?: AbstractSyntaxMode
  /** Custom abstract syntaxes (SOP Class UIDs) to accept when mode is 'Custom' */
  abstractSyntaxes?: Array<'CTImageStorage' | 'EnhancedCTImageStorage' | 'MRImageStorage' | 'EnhancedMRImageStorage' | 'UltrasoundImageStorage' | 'UltrasoundMultiFrameImageStorage' | 'SecondaryCaptureImageStorage' | 'MultiFrameGrayscaleByteSecondaryCaptureImageStorage' | 'MultiFrameGrayscaleWordSecondaryCaptureImageStorage' | 'MultiFrameTrueColorSecondaryCaptureImageStorage' | 'ComputedRadiographyImageStorage' | 'DigitalXRayImageStorageForPresentation' | 'DigitalXRayImageStorageForProcessing' | 'DigitalMammographyXRayImageStorageForPresentation' | 'DigitalMammographyXRayImageStorageForProcessing' | 'BreastTomosynthesisImageStorage' | 'BreastProjectionXRayImageStorageForPresentation' | 'BreastProjectionXRayImageStorageForProcessing' | 'PositronEmissionTomographyImageStorage' | 'EnhancedPETImageStorage' | 'NuclearMedicineImageStorage' | 'RTImageStorage' | 'RTDoseStorage' | 'RTStructureSetStorage' | 'RTPlanStorage' | 'EncapsulatedPDFStorage' | 'EncapsulatedCDAStorage' | 'EncapsulatedSTLStorage' | 'GrayscaleSoftcopyPresentationStateStorage' | 'BasicTextSRStorage' | 'EnhancedSRStorage' | 'ComprehensiveSRStorage' | 'Verification' | (string & {})>
  /** Transfer syntax acceptance mode (default: 'All') */
  transferSyntaxMode?: TransferSyntaxMode
  /** Custom transfer syntaxes to accept when mode is 'Custom' */
  transferSyntaxes?: Array<'ImplicitVRLittleEndian' | 'ExplicitVRLittleEndian' | 'ExplicitVRBigEndian' | 'DeflatedExplicitVRLittleEndian' | 'JPEGBaseline' | 'JPEGExtended' | 'JPEGLossless' | 'JPEGLosslessNonHierarchical' | 'JPEGLSLossless' | 'JPEGLSLossy' | 'JPEG2000Lossless' | 'JPEG2000' | 'RLELossless' | 'MPEG2MainProfile' | 'MPEG2MainProfileHighLevel' | 'MPEG4AVCH264HighProfile' | 'MPEG4AVCH264BDCompatibleHighProfile' | (string & {})>
  /** TCP port to listen on (required) */
  port: number
  /** Timeout in seconds before triggering OnStudyCompleted event (default: 30) */
  studyTimeout?: number
  /** Storage backend: 'Filesystem' or 'S3' (default: 'Filesystem') */
  storageBackend?: StorageBackendType
  /** S3 configuration (required if storageBackend is 'S3') */
  s3Config?: S3Config
  /** Output directory for filesystem storage (default: current directory) */
  outDir?: string
  /** Store complete DICOM files with meta header vs dataset-only (default: false) */
  storeWithFileMeta?: boolean
  /** DICOM tags to extract from received files (e.g., ['PatientName', 'StudyDate']) */
  extractTags?: Array<'AccessionNumber' | 'AcquisitionDate' | 'AcquisitionDateTime' | 'AcquisitionNumber' | 'AcquisitionTime' | 'ActualCardiacTriggerTimePriorToRPeak' | 'ActualFrameDuration' | 'AdditionalPatientHistory' | 'AdmissionID' | 'AdmittingDiagnosesDescription' | 'AnatomicalOrientationType' | 'AnatomicRegionSequence' | 'AnodeTargetMaterial' | 'BeamLimitingDeviceAngle' | 'BitsAllocated' | 'BitsStored' | 'BluePaletteColorLookupTableDescriptor' | 'BodyPartExamined' | 'BodyPartThickness' | 'BranchOfService' | 'BurnedInAnnotation' | 'ChannelSensitivity' | 'CineRate' | 'CollimatorType' | 'Columns' | 'CompressionForce' | 'ContentDate' | 'ContentTime' | 'ContrastBolusAgent' | 'ContrastBolusIngredient' | 'ContrastBolusIngredientConcentration' | 'ContrastBolusRoute' | 'ContrastBolusStartTime' | 'ContrastBolusStopTime' | 'ContrastBolusTotalDose' | 'ContrastBolusVolume' | 'ContrastFlowDuration' | 'ContrastFlowRate' | 'ConvolutionKernel' | 'CorrectedImage' | 'CountsSource' | 'DataCollectionDiameter' | 'DecayCorrection' | 'DeidentificationMethod' | 'DerivationDescription' | 'DetectorTemperature' | 'DeviceSerialNumber' | 'DistanceSourceToDetector' | 'DistanceSourceToPatient' | 'EchoTime' | 'EthnicGroup' | 'Exposure' | 'ExposureInMicroAmpereSeconds' | 'ExposureTime' | 'FilterType' | 'FlipAngle' | 'FocalSpots' | 'FrameDelay' | 'FrameIncrementPointer' | 'FrameOfReferenceUID' | 'FrameTime' | 'GantryAngle' | 'GeneratorPower' | 'GraphicAnnotationSequence' | 'GreenPaletteColorLookupTableDescriptor' | 'HeartRate' | 'HighBit' | 'ImageComments' | 'ImageLaterality' | 'ImageOrientationPatient' | 'ImagePositionPatient' | 'ImagerPixelSpacing' | 'ImageTriggerDelay' | 'ImageType' | 'ImagingFrequency' | 'ImplementationClassUID' | 'ImplementationVersionName' | 'InstanceCreationDate' | 'InstanceCreationTime' | 'InstanceNumber' | 'InstitutionName' | 'IntensifierSize' | 'IssuerOfAdmissionID' | 'KVP' | 'LargestImagePixelValue' | 'LargestPixelValueInSeries' | 'Laterality' | 'LossyImageCompression' | 'LossyImageCompressionMethod' | 'LossyImageCompressionRatio' | 'MagneticFieldStrength' | 'Manufacturer' | 'ManufacturerModelName' | 'MedicalRecordLocator' | 'MilitaryRank' | 'Modality' | 'MultiplexGroupTimeOffset' | 'NameOfPhysiciansReadingStudy' | 'NominalCardiacTriggerDelayTime' | 'NominalInterval' | 'NumberOfFrames' | 'NumberOfSlices' | 'NumberOfTemporalPositions' | 'NumberOfWaveformChannels' | 'NumberOfWaveformSamples' | 'Occupation' | 'OperatorsName' | 'OtherPatientIDs' | 'OtherPatientNames' | 'OverlayBitPosition' | 'OverlayBitsAllocated' | 'OverlayColumns' | 'OverlayData' | 'OverlayOrigin' | 'OverlayRows' | 'OverlayType' | 'PaddleDescription' | 'PatientAge' | 'PatientBirthDate' | 'PatientBreedDescription' | 'PatientComments' | 'PatientID' | 'PatientIdentityRemoved' | 'PatientName' | 'PatientPosition' | 'PatientSex' | 'PatientSize' | 'PatientSpeciesDescription' | 'PatientSupportAngle' | 'PatientTelephoneNumbers' | 'PatientWeight' | 'PerformedProcedureStepDescription' | 'PerformedProcedureStepID' | 'PerformedProcedureStepStartDate' | 'PerformedProcedureStepStartTime' | 'PerformedProtocolCodeSequence' | 'PerformingPhysicianName' | 'PhotometricInterpretation' | 'PhysiciansOfRecord' | 'PixelAspectRatio' | 'PixelPaddingRangeLimit' | 'PixelPaddingValue' | 'PixelRepresentation' | 'PixelSpacing' | 'PlanarConfiguration' | 'PositionerPrimaryAngle' | 'PositionerSecondaryAngle' | 'PositionReferenceIndicator' | 'PreferredPlaybackSequencing' | 'PresentationIntentType' | 'PresentationLUTShape' | 'PrimaryAnatomicStructureSequence' | 'PrivateInformationCreatorUID' | 'ProtocolName' | 'QualityControlImage' | 'RadiationMachineName' | 'RadiationSetting' | 'RadionuclideTotalDose' | 'RadiopharmaceuticalInformationSequence' | 'RadiopharmaceuticalStartDateTime' | 'RadiopharmaceuticalStartTime' | 'RadiopharmaceuticalVolume' | 'ReasonForTheRequestedProcedure' | 'ReceivingApplicationEntityTitle' | 'RecognizableVisualFeatures' | 'RecommendedDisplayFrameRate' | 'ReconstructionDiameter' | 'ReconstructionTargetCenterPatient' | 'RedPaletteColorLookupTableDescriptor' | 'ReferencedBeamNumber' | 'ReferencedImageSequence' | 'ReferencedPatientPhotoSequence' | 'ReferencedPerformedProcedureStepSequence' | 'ReferencedRTPlanSequence' | 'ReferencedSOPClassUID' | 'ReferencedSOPInstanceUID' | 'ReferencedStudySequence' | 'ReferringPhysicianName' | 'RepetitionTime' | 'RequestAttributesSequence' | 'RequestedContrastAgent' | 'RequestedProcedureDescription' | 'RequestedProcedureID' | 'RequestingPhysician' | 'RescaleIntercept' | 'RescaleSlope' | 'RescaleType' | 'ResponsibleOrganization' | 'ResponsiblePerson' | 'ResponsiblePersonRole' | 'Rows' | 'RTImageDescription' | 'RTImageLabel' | 'SamplesPerPixel' | 'SamplingFrequency' | 'ScanningSequence' | 'SendingApplicationEntityTitle' | 'SeriesDate' | 'SeriesDescription' | 'SeriesInstanceUID' | 'SeriesNumber' | 'SeriesTime' | 'SeriesType' | 'SliceLocation' | 'SliceThickness' | 'SmallestImagePixelValue' | 'SmallestPixelValueInSeries' | 'SoftwareVersions' | 'SOPClassUID' | 'SOPInstanceUID' | 'SoundPathLength' | 'SourceApplicationEntityTitle' | 'SourceImageSequence' | 'SpacingBetweenSlices' | 'SpecificCharacterSet' | 'StationName' | 'StudyComments' | 'StudyDate' | 'StudyDescription' | 'StudyID' | 'StudyInstanceUID' | 'StudyTime' | 'TableHeight' | 'TableTopLateralPosition' | 'TableTopLongitudinalPosition' | 'TableTopVerticalPosition' | 'TableType' | 'TemporalPositionIdentifier' | 'TemporalResolution' | 'TextObjectSequence' | 'TimezoneOffsetFromUTC' | 'TransducerFrequency' | 'TransducerType' | 'TransferSyntaxUID' | 'TriggerTime' | 'TriggerTimeOffset' | 'UltrasoundColorDataPresent' | 'Units' | 'VOILUTFunction' | 'WaveformOriginality' | 'WaveformSequence' | 'WindowCenter' | 'WindowCenterWidthExplanation' | 'WindowWidth' | 'XRayTubeCurrent' | (string & {})>
  /** Custom private tags to extract with user-defined names */
  extractCustomTags?: Array<CustomTag>
  /** Grouping strategy for extracted tags: 'ByScope' | 'Flat' | 'StudyLevel' | 'Custom' (default: 'ByScope') */
  groupingStrategy?: 'ByScope' | 'Flat' | 'StudyLevel' | 'Custom' | (string & {})
}

/** * Events emitted by the DICOM C-STORE SCU client during file transfer operations.
 *
 * Use these events to monitor the progress of DICOM file transfers to a remote SCP.
 *
 * @example
 * ```typescript
 * const scu = new StoreScu({ addr: 'MY-SCP@192.168.1.100:11112' });
 * scu.addFile('image.dcm');
 *
 * scu.addEventListener('OnTransferStarted', (data) => {
 *   const info = JSON.parse(data.data!);
 *   console.log(`Starting transfer of ${info.totalFiles} files`);
 * });
 *
 * scu.addEventListener('OnFileSending', (data) => {
 *   const info = JSON.parse(data.data!);
 *   console.log(`Sending: ${info.file}`);
 * });
 *
 * scu.addEventListener('OnFileSent', (data) => {
 *   const info = JSON.parse(data.data!);
 *   console.log(`✓ Sent: ${info.sopInstanceUid}`);
 * });
 *
 * scu.addEventListener('OnTransferCompleted', (data) => {
 *   console.log('All files transferred successfully');
 * });
 *
 * await scu.send();
 * ```
 */
export declare const enum StoreScuEvent {
  /** Transfer operation has started (emitted once at the beginning) */
  OnTransferStarted = 'OnTransferStarted',
  /** A file is about to be sent (emitted for each file) */
  OnFileSending = 'OnFileSending',
  /** A file has been successfully sent (emitted for each file) */
  OnFileSent = 'OnFileSent',
  /** An error occurred while sending a specific file */
  OnFileError = 'OnFileError',
  /** All files have been transferred successfully (emitted once at the end) */
  OnTransferCompleted = 'OnTransferCompleted',
  /** A general error occurred during the transfer operation */
  OnError = 'OnError'
}

/** * Configuration options for the DICOM C-STORE SCU client.
 *
 * @example
 * ```typescript
 * // Basic local file transfer
 * const options1: StoreScuOptions = {
 *   addr: 'STORE-SCP@192.168.1.100:11112',
 *   callingAeTitle: 'MY-SCU',
 *   verbose: true
 * };
 *
 * // Transfer from S3 with authentication
 * const options2: StoreScuOptions = {
 *   addr: 'PACS@pacs.hospital.com:104',
 *   callingAeTitle: 'CLOUD-SCU',
 *   username: 'dicom-user',
 *   password: 'secret',
 *   s3Config: {
 *     bucket: 'dicom-images',
 *     accessKey: process.env.AWS_ACCESS_KEY!,
 *     secretKey: process.env.AWS_SECRET_KEY!,
 *     region: 'us-east-1'
 *   },
 *   concurrency: 4
 * };
 *
 * // High-performance transfer with custom settings
 * const options3: StoreScuOptions = {
 *   addr: '192.168.1.100:11112',
 *   maxPduLength: 131072,
 *   concurrency: 8,
 *   failFirst: false,
 *   neverTranscode: false
 * };
 * ```
 */
export interface StoreScuOptions {
  /** Address of the Store SCP, optionally with AE title (e.g., "STORE-SCP@127.0.0.1:11112" or "192.168.1.100:104") */
  addr: string
  /** Enable verbose logging (default: false) */
  verbose?: boolean
  /** C-STORE message ID (default: 1) */
  messageId?: number
  /** Calling Application Entity title for this SCU (default: "STORE-SCU") */
  callingAeTitle?: string
  /** Called Application Entity title, overrides AE title in address if present (default: "ANY-SCP") */
  calledAeTitle?: string
  /** Maximum PDU length in bytes, range 4096-131072 (default: 16384) */
  maxPduLength?: number
  /** Stop transfer immediately if any file fails (default: false) */
  failFirst?: boolean
  /** Fail transfer if transcoding would be required (default: true) */
  neverTranscode?: boolean
  /** Accept files with any SOP class UID, not only those in presentation contexts (default: false) */
  ignoreSopClass?: boolean
  /** User Identity username for authentication */
  username?: string
  /** User Identity password for authentication */
  password?: string
  /** User Identity Kerberos service ticket */
  kerberosServiceTicket?: string
  /** User Identity SAML assertion */
  samlAssertion?: string
  /** User Identity JWT (JSON Web Token) */
  jwt?: string
  /** Number of parallel connections for concurrent file transfer (default: 1) */
  concurrency?: number
  /** S3 configuration for reading files from S3 storage (required if using S3 paths) */
  s3Config?: S3Config
}

/** Study hierarchy data for OnStudyCompleted event */
export interface StudyHierarchyData {
  studyInstanceUid: string
  tagsScoped?: ScopedDicomData
  tagsFlat?: Record<string, string>
  tagsStudyLevel?: StudyLevelData
  series: Array<SeriesHierarchyData>
}

/** * DICOM data extracted and grouped by study level.
 *
 * Result structure when using `GroupingStrategy.StudyLevel`.
 * Separates data that persists across all instances in a study (study-level)
 * from data that varies per file (instance-level).
 *
 * ## Two-Tier Structure
 * - **studyLevel**: Patient + Study tags (same for all instances in a study)
 * - **instanceLevel**: Series + Instance + Equipment tags (varies per file)
 * - **custom**: User-defined custom/private tags
 *
 * This grouping is particularly useful for:
 * - Study deduplication (use studyLevel as the key)
 * - Batch processing (group files by studyLevel)
 * - Database optimization (separate study and instance tables)
 * - Study aggregation (combine multiple instances using studyLevel)
 *
 * @example
 * ```typescript
 * import { DicomFile, StudyLevelData } from '@nuxthealth/node-dicom';
 *
 * const dicom = new DicomFile();
 * dicom.open('series1-image1.dcm');
 *
 * const json = dicom.extract(
 *   [
 *     'PatientID', 'PatientName',           // Study-level
 *     'StudyInstanceUID', 'StudyDate',      // Study-level
 *     'SeriesNumber', 'InstanceNumber',     // Instance-level
 *     'SOPInstanceUID', 'Modality'          // Instance-level
 *   ],
 *   undefined,
 *   'StudyLevel'
 * );
 *
 * const data: StudyLevelData = JSON.parse(json);
 *
 * // Study-level data (same for all instances in this study)
 * console.log('Study Key:');
 * console.log(data.studyLevel);
 * // {
 * //   PatientID: '12345',
 * //   PatientName: 'DOE^JOHN',
 * //   StudyInstanceUID: '1.2.3.4.5...',
 * //   StudyDate: '20240101'
 * // }
 *
 * // Instance-level data (unique per file)
 * console.log('Instance Data:');
 * console.log(data.instanceLevel);
 * // {
 * //   SeriesNumber: '1',
 * //   InstanceNumber: '1',
 * //   SOPInstanceUID: '1.2.3.4.5.6...',
 * //   Modality: 'CT'
 * // }
 * ```
 *
 * @example
 * ```typescript
 * // Study deduplication workflow
 * interface StudyKey {
 *   PatientID: string;
 *   StudyInstanceUID: string;
 * }
 *
 * const studyMap = new Map<string, StudyKey>();
 * const files = ['img1.dcm', 'img2.dcm', 'img3.dcm'];
 *
 * for (const file of files) {
 *   const dicom = new DicomFile();
 *   dicom.open(file);
 *
 *   const json = dicom.extract(
 *     ['PatientID', 'StudyInstanceUID', 'SOPInstanceUID'],
 *     undefined,
 *     'StudyLevel'
 *   );
 *
 *   const data: StudyLevelData = JSON.parse(json);
 *
 *   // Use studyLevel as deduplication key
 *   const studyKey = JSON.stringify(data.studyLevel);
 *   if (!studyMap.has(studyKey)) {
 *     studyMap.set(studyKey, data.studyLevel as any);
 *     console.log('New study:', studyKey);
 *   }
 *
 *   // Process instance-specific data
 *   console.log('Instance:', data.instanceLevel?.SOPInstanceUID);
 * }
 *
 * console.log(`Total unique studies: ${studyMap.size}`);
 * ```
 *
 * @example
 * ```typescript
 * // Database insertion with normalized schema
 * import { DicomFile, StudyLevelData } from '@nuxthealth/node-dicom';
 *
 * async function importDicomToDb(filePath: string, db: Database) {
 *   const dicom = new DicomFile();
 *   dicom.open(filePath);
 *
 *   const json = dicom.extract(
 *     ['PatientID', 'StudyInstanceUID', 'SeriesInstanceUID', 'SOPInstanceUID'],
 *     undefined,
 *     'StudyLevel'
 *   );
 *
 *   const data: StudyLevelData = JSON.parse(json);
 *
 *   // Insert or update study table (study-level data)
 *   await db.upsert('studies', data.studyLevel);
 *
 *   // Insert instance table (instance-level data)
 *   await db.insert('instances', {
 *     ...data.instanceLevel,
 *     filePath: filePath
 *   });
 * }
 * ```
 */
export interface StudyLevelData {
  /** Study-level data: Patient + Study tags (persists across all instances) */
  studyLevel?: Record<string, string>
  /** Instance-level data: Series + Instance + Equipment tags (varies per file) */
  instanceLevel?: Record<string, string>
  /** Custom/private tags with user-defined names */
  custom?: Record<string, string>
}

/** Tag scope classification based on DICOM hierarchy */
export declare const enum TagScope {
  Patient = 'Patient',
  Study = 'Study',
  Series = 'Series',
  Instance = 'Instance',
  Equipment = 'Equipment'
}

/** * Event data for OnTransferCompleted event.
 *
 * Emitted once when all files have been transferred.
 */
export interface TransferCompletedEvent {
  message: string
  totalFiles: number
  successful: number
  failed: number
  durationSeconds: number
}

/** * Event data for OnTransferStarted event.
 *
 * Emitted once at the beginning of a transfer operation.
 */
export interface TransferStartedEvent {
  message: string
  totalFiles: number
}

/** Transfer Syntax configuration object */
export interface TransferSyntaxConfig {
  /** Uncompressed transfer syntaxes */
  uncompressed: Array<string>
  /** JPEG transfer syntaxes */
  jpeg: Array<string>
  /** JPEG-LS transfer syntaxes */
  jpegLs: Array<string>
  /** JPEG 2000 transfer syntaxes */
  jpeg2000: Array<string>
  /** RLE transfer syntax */
  rle: Array<string>
  /** MPEG video transfer syntaxes */
  mpeg: Array<string>
  /** All compressed transfer syntaxes */
  allCompressed: Array<string>
  /** All transfer syntaxes */
  all: Array<string>
}

/** Transfer syntax acceptance mode */
export declare const enum TransferSyntaxMode {
  /** Accept all supported transfer syntaxes (default) */
  All = 'All',
  /** Accept only uncompressed transfer syntaxes */
  UncompressedOnly = 'UncompressedOnly',
  /** Accept only specified transfer syntaxes */
  Custom = 'Custom'
}
